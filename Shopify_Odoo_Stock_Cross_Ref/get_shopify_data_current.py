"""
Shopify Inventory CSV Importer

This script imports Shopify inventory data from a CSV file into a local SQLite database.
It is designed to work with the standard inventory export file generated by Shopify.

To use this script:
1. Export your inventory from the Shopify Admin (Products > Inventory > Export).
2. Place the exported CSV file (e.g., 'inventory_export_1.csv') into the 'shared-data/input' directory.
3. Run the main sync script, which will call this importer.

The script will automatically find the most recent inventory export file, parse it,
and update the local 'shopifyproducts' and 'shopify_inventory' tables.
"""

import pandas as pd
import sqlite3
import argparse
import sys
import json
import datetime
import os
import requests
import time
import sys
import os

# Add parent directory to path to import from root
sys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))
from shopify_export_cred import access_token, clean_shop_url, db_name

# --- Path Setup ---
SCRIPT_DIR = os.path.dirname(os.path.abspath(__file__))
PROJECT_ROOT = os.path.abspath(os.path.join(SCRIPT_DIR, '..'))
SHARED_DATA_DIR = os.path.join(PROJECT_ROOT, 'shared-data')
SQLITE_DIR = os.path.join(SHARED_DATA_DIR, 'sqlite')
INPUT_DIR = os.path.join(SHARED_DATA_DIR, 'input')
DB_PATH = os.path.join(SQLITE_DIR, 'analytics.db')

# Get the output directory from the environment variable set by the runner.
OUTPUT_DIR = os.environ.get('OUTPUT_DIR')
if not OUTPUT_DIR:
    print("Warning: OUTPUT_DIR environment variable not set. Defaulting to 'shared-data/output/default'.")
    OUTPUT_DIR = os.path.join(SHARED_DATA_DIR, 'output', 'default')

# Create directories if they don't exist
os.makedirs(SQLITE_DIR, exist_ok=True)
os.makedirs(INPUT_DIR, exist_ok=True)
os.makedirs(OUTPUT_DIR, exist_ok=True)

class ShopifyInventoryImporter:
    def __init__(self, verbose=False, silent=False):
        self.verbose = verbose
        self.silent = silent
        # Silent mode overrides verbose mode
        if self.silent:
            self.verbose = False

    def info(self, message, end='\n'):
        """Prints a message unless in silent mode. For standard user feedback."""
        if not self.silent:
            print(message, end=end, flush=True)

    def log(self, message):
        """Prints a message only if verbose mode is on. For detailed debugging."""
        if self.verbose:
            print(message)

    def find_latest_inventory_export(self):
        """Find the most recent inventory export CSV file from the shared input directory."""
        try:
            inventory_files = [f for f in os.listdir(INPUT_DIR) if f.startswith('inventory_export') and f.endswith('.csv')]
        except FileNotFoundError:
            inventory_files = []

        if not inventory_files:
            self.info("Warning: No inventory export files found in 'shared-data/input/'.")
            return None
        
        # Sort by modification time (newest first)
        inventory_files.sort(key=lambda f: os.path.getmtime(os.path.join(INPUT_DIR, f)), reverse=True)
        latest_file_name = inventory_files[0]
        latest_file_path = os.path.join(INPUT_DIR, latest_file_name)
        
        self.info(f"Using most recent inventory file: {latest_file_path}")
        return latest_file_path
        
    def download_inventory_export(self):
        """Triggers a Shopify inventory export and downloads the resulting CSV."""
        self.info("Requesting Shopify inventory export...")
        api_version = '2024-04'
        url = f"https://{clean_shop_url}/admin/api/{api_version}/graphql.json"
        headers = {
            "X-Shopify-Access-Token": access_token,
            "Content-Type": "application/json"
        }
        
        # Step 1: Start the bulk operation
        mutation = """
        mutation {
          bulkOperationRunQuery(
           query: \"\"\"
            {
              products {
                edges {
                  node {
                    id
                    title
                    handle
                    status
                    variants {
                      edges {
                        node {
                          id
                          sku
                          title
                          inventoryQuantity
                          inventoryItem {
                            id
                            tracked
                            inventoryLevels {
                              edges {
                                node {
                                  id
                                  quantities(names: ["available", "on_hand", "committed", "incoming"]) {
                                    name
                                    quantity
                                  }
                                  location {
                                    id
                                    name
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
            \"\"\"
          ) {
            bulkOperation {
              id
              status
            }
            userErrors {
              field
              message
            }
          }
        }
        """
        
        response = requests.post(url, json={'query': mutation}, headers=headers)
        if response.status_code != 200 or 'errors' in response.json() or response.json()['data']['bulkOperationRunQuery']['userErrors']:
            self.info(f"Error starting Shopify export: {response.text}")
            return None
            
        operation_id = response.json()['data']['bulkOperationRunQuery']['bulkOperation']['id']
        self.info(f"Bulk operation started with ID: {operation_id}")

        # Step 2: Poll for completion
        query = """
        query {
          node(id: "%s") {
            ... on BulkOperation {
              id
              status
              errorCode
              createdAt
              completedAt
              objectCount
              fileSize
              url
              partialDataUrl
            }
          }
        }
        """ % operation_id

        while True:
            self.info("Polling for export completion...")
            time.sleep(5)
            response = requests.post(url, json={'query': query}, headers=headers)
            if response.status_code != 200:
                self.info(f"Error polling for status: {response.text}")
                return None
            
            data = response.json()['data']['node']
            if data['status'] == 'COMPLETED':
                download_url = data['url']
                break
            elif data['status'] in ['FAILED', 'CANCELED']:
                self.info(f"Export failed with status: {data['status']}")
                return None

        # Step 3: Download the file
        self.info(f"Export complete. Downloading from: {download_url}")
        response = requests.get(download_url)
        if response.status_code != 200:
            self.info(f"Error downloading file: {response.status_code}")
            return None
            
        # Save the file
        file_path = os.path.join(INPUT_DIR, 'inventory_export_latest.csv')
        with open(file_path, 'wb') as f:
            f.write(response.content)
            
        self.info(f"Inventory export saved to: {file_path}")
        return file_path

    def import_inventory(self, csv_file=None):
        """
        Import Shopify inventory data from CSV file into SQLite database.
        If no CSV file is provided, trigger a new download.
        """
        if csv_file is None:
            csv_file = self.download_inventory_export()
            if csv_file is None:
                self.info("Failed to download inventory export from Shopify.")
                return None
                
        self.info(f"Importing Shopify inventory data from {csv_file}...")
        
        # The file is in JSONL format. We need a multi-pass approach.
        # Pass 1: Get all the parent product info.
        product_info = {}
        # Pass 2: Get all variant info
        variant_info = {}
        # Pass 3: Get all inventory level info
        inventory_levels = {}
        
        with open(csv_file, 'r', encoding='utf-8') as f:
            for line in f:
                data = json.loads(line)
                
                # Product records (no __parentId)
                if 'id' in data and 'title' in data and 'handle' in data and not data.get('__parentId'):
                    product_info[data['id']] = {
                        'title': data['title'],
                        'handle': data['handle'],
                        'status': data.get('status', 'active')
                    }
                
                # Variant records (have __parentId and sku)
                elif data.get('__parentId') and 'sku' in data:
                    variant_info[data['id']] = {
                        'product_id': data['__parentId'],
                        'sku': data.get('sku'),
                        'title': data.get('title'),
                        'inventoryQuantity': data.get('inventoryQuantity', 0)
                    }
                
                # Inventory level records (have __parentId and quantities)
                elif data.get('__parentId') and 'quantities' in data:
                    parent_variant_id = data['__parentId']
                    if parent_variant_id not in inventory_levels:
                        inventory_levels[parent_variant_id] = []
                    
                    # Parse quantities for this location
                    location_data = {
                        'location': data.get('location', {}),
                        'available': 0,
                        'on_hand': 0,
                        'committed': 0,
                        'incoming': 0
                    }
                    
                    for qty in data.get('quantities', []):
                        qty_name = qty.get('name', '')
                        qty_value = qty.get('quantity', 0)
                        if qty_name in location_data:
                            location_data[qty_name] = qty_value
                    
                    inventory_levels[parent_variant_id].append(location_data)

        # Pass 4: Combine all data into records
        records = []
        for variant_id, variant in variant_info.items():
            product = product_info.get(variant['product_id'], {})
            levels = inventory_levels.get(variant_id, [])
            
            # Aggregate inventory across all locations
            total_available = 0
            total_on_hand = 0
            total_committed = 0
            total_incoming = 0
            
            for level in levels:
                total_available += level['available']
                total_on_hand += level['on_hand']
                total_committed += level['committed']
                total_incoming += level['incoming']
                
                # Log location details for debugging
                if self.verbose and level['location'] and (level['on_hand'] > 0 or variant['sku'] in ['MYRI-RUBR-01G']):
                    self.log(f"SKU {variant['sku']}: Location {level['location'].get('name', 'Unknown')} - Available: {level['available']}, On Hand: {level['on_hand']}, Committed: {level['committed']}")
            
            # Calculate unavailable as on_hand - available
            total_unavailable = max(0, total_on_hand - total_available)
            
            # If no inventory levels found, use variant's basic inventory quantity
            if not levels:
                total_available = variant['inventoryQuantity']
                total_on_hand = variant['inventoryQuantity']
                if self.verbose and (total_on_hand > 0 or variant['sku'] in ['MYRI-RUBR-01G']):
                    self.log(f"No inventory levels found for SKU {variant['sku']}, using basic quantity: {total_on_hand}")
            
            records.append({
                'product_id': variant['product_id'],
                'title': product.get('title'),
                'handle': product.get('handle'),
                'status': product.get('status', 'active'),
                'sku': variant['sku'],
                'on_hand': total_on_hand,
                'available': total_available,
                'committed': total_committed,
                'unavailable': total_unavailable,
                'incoming': total_incoming,
                'option_value': variant['title']  # Variant title as option value
            })

        if not records:
            self.info("No product variant records found in the downloaded file.")
            return None

        df = pd.DataFrame(records)
        self.log(f"Parsed {len(df)} variant records from JSONL file with comprehensive inventory data")
        
        # Log summary of inventory categories found
        total_available = df['available'].sum()
        total_committed = df['committed'].sum()
        total_incoming = df['incoming'].sum()
        total_unavailable = df['unavailable'].sum()
        self.info(f"Inventory summary - Available: {total_available}, Committed: {total_committed}, Incoming: {total_incoming}, Unavailable: {total_unavailable}")

        # Group by SKU and aggregate inventory values
        inventory_by_sku = df.groupby('sku').agg({
            'incoming': 'sum',
            'unavailable': 'sum',
            'committed': 'sum',
            'available': 'sum',
            'on_hand': 'sum',
            'title': 'first',
            'handle': 'first',
            'option_value': 'first'
        }).reset_index()
        
        self.log(f"Aggregated to {len(inventory_by_sku)} unique SKUs")
        
        # Connect to the database
        conn = sqlite3.connect(DB_PATH)
        cursor = conn.cursor()
        
        # Create shopify_inventory table if it doesn't exist
        cursor.execute("""
        CREATE TABLE IF NOT EXISTS shopify_inventory (
            sku TEXT PRIMARY KEY,
            title TEXT,
            handle TEXT,
            option_value TEXT,
            incoming REAL,
            unavailable REAL,
            committed REAL,
            available REAL,
            on_hand REAL,
            import_date TEXT
        )
        """)
        
        # Add import date
        inventory_by_sku['import_date'] = datetime.datetime.now().isoformat()
        
        # The new dataframe has the correct column names, so no renaming is needed.
        
        # Insert or replace data in the table
        inventory_by_sku.to_sql('shopify_inventory', conn, if_exists='replace', index=False)
        
        # Print column names for debugging
        cursor.execute("PRAGMA table_info(shopify_inventory)")
        columns = cursor.fetchall()
        self.log(f"Columns in shopify_inventory table: {[c[1] for c in columns]}")
        
        self.info(f"Imported {len(inventory_by_sku)} SKUs into shopify_inventory table")
        
        # Also create the shopifyproducts table with the same data
        # This ensures compatibility with existing code that expects this table
        self.log("Creating shopifyproducts table with the same data...")
        
        # Create a DataFrame for shopifyproducts with the necessary columns
        shopify_products = pd.DataFrame({
            'sku': inventory_by_sku['sku'],
            'title': inventory_by_sku['title'],
            'handle': inventory_by_sku['handle'],
            'option1': inventory_by_sku['option_value'],
            'inventory_quantity': inventory_by_sku['on_hand'],
            'old_inventory_quantity': inventory_by_sku['on_hand'],
            'status': 'active'  # Assume all products with inventory are active
        })
        
        # Replace the shopifyproducts table
        shopify_products.to_sql('shopifyproducts', conn, if_exists='replace', index=False)
        self.log(f"Created shopifyproducts table with {len(shopify_products)} records")
        
        # Update the last_update timestamp
        timestamp_df = pd.DataFrame([{'last_updated': datetime.datetime.now().isoformat()}])
        timestamp_df.to_sql('last_update', conn, if_exists='replace', index=False)
        self.log("Updated last_update timestamp")
        
        conn.close()
        return True
        
    def export_to_excel(self):
        """Export inventory data to Excel files."""
        conn = sqlite3.connect(DB_PATH)
        
        # Check if odoostock table exists
        cursor = conn.cursor()
        cursor.execute("SELECT name FROM sqlite_master WHERE type='table' AND name='odoostock'")
        odoostock_exists = cursor.fetchone() is not None
        
        if not odoostock_exists:
            self.info("Warning: odoostock table not found. Run get_odoo_stock_current.py first.")
            self.info("Skipping stock cross-reference creation.")
            conn.close()
            return None
        
        # Create a new stock cross-reference view that includes all inventory values
        cursor.execute("DROP VIEW IF EXISTS stock_cross_reference_extended")
        
        cursor.execute("""
        CREATE VIEW stock_cross_reference_extended AS
        SELECT
            o.product_id,
            o.location_id,
            o.default_code AS odoo_sku,
            o.quantity AS odoo_quantity,
            o.quantity AS odoo_available,
            si.sku AS shopify_sku,
            si.title AS shopify_title,
            si.option_value AS shopify_option,
            si.on_hand AS shopify_on_hand,
            si.available AS shopify_available,
            si.committed AS shopify_committed,
            si.unavailable AS shopify_unavailable,
            si.incoming AS shopify_incoming,
            CASE
                WHEN si.on_hand IS NOT NULL THEN o.quantity - si.on_hand
                ELSE o.quantity
            END AS quantity_diff,
            CASE
                WHEN si.available IS NOT NULL THEN o.quantity - si.available
                ELSE o.quantity
            END AS available_diff
        FROM
            odoostock o
        LEFT JOIN
            shopify_inventory si ON o.default_code = si.sku
        WHERE
            o.quantity > 0 OR si.on_hand > 0
        ORDER BY
            CASE
                WHEN si.on_hand IS NOT NULL THEN ABS(o.quantity - si.on_hand)
                ELSE o.quantity
            END DESC
        """)
        
        # Export the view to Excel
        excel_file = os.path.join(OUTPUT_DIR, 'stock_cross_reference_extended.xlsx')
        
        try:
            df_cross_ref = pd.read_sql("SELECT * FROM stock_cross_reference_extended", conn)
            
            # Check if file exists and is not open
            if os.path.exists(excel_file):
                try:
                    # Try to open and close the file to check if it's accessible
                    with open(excel_file, 'a'):
                        pass
                    # If we get here, file is accessible, so we can overwrite it
                    df_cross_ref.to_excel(excel_file, index=False)
                except (IOError, PermissionError):
                    print(f"Warning: Could not update {excel_file} - file may be open in another program")
            else:
                # File doesn't exist, so we can create it
                df_cross_ref.to_excel(excel_file, index=False)
            
            self.info(f"Exported {len(df_cross_ref)} rows to {excel_file}")
            
            # Automatically open the Excel file in user's default application
            try:
                os.startfile(excel_file)
                self.info(f"Opened Excel file: {excel_file}")
            except Exception as e:
                self.log(f"Could not automatically open Excel file: {e}")
            
            # Also save a copy without timestamp for easier reference
            try:
                standard_excel_file = os.path.join(OUTPUT_DIR, 'stock_cross_reference_extended.xlsx')
                df_cross_ref.to_excel(standard_excel_file, index=False)
                self.log(f"Also saved copy to {standard_excel_file}")
            except Exception as e:
                self.log(f"Warning: Could not save copy to {standard_excel_file}: {e}")
                
        except Exception as e:
            self.info(f"Error creating stock cross-reference report: {e}")
            excel_file = None
            
        conn.close()
        return excel_file


def main():
    """Main function to run the Shopify inventory import process."""
    # Set up argument parser
    parser = argparse.ArgumentParser(
        description='Import Shopify inventory data from CSV exports',
        formatter_class=argparse.RawTextHelpFormatter
    )
    
    # Output control group
    output_group = parser.add_mutually_exclusive_group()
    output_group.add_argument('-v', '--verbose', action='store_true', help='Show detailed (verbose) progress information.')
    output_group.add_argument('--silent', action='store_true', help='Suppress all output except for errors. Useful for automation.')
    
    # Functionality arguments
    parser.add_argument('-e', '--export', action='store_true', help='Export data to Excel after importing.')
    parser.add_argument('-c', '--csv-file', help='Specify a CSV file to import instead of using the most recent one.')
    
    # Parse arguments
    args = parser.parse_args()
    
    try:
        # Initialize importer with verbosity setting
        importer = ShopifyInventoryImporter(verbose=args.verbose, silent=args.silent)
        
        # Import inventory data
        csv_file = args.csv_file
        success = importer.import_inventory(csv_file=args.csv_file)
        
        if not success:
            sys.stderr.write("\nFailed to import inventory data.\n")
            sys.exit(1)
            
        # Export to Excel if requested
        if args.export:
            excel_file = importer.export_to_excel()
            if excel_file:
                importer.info(f"Excel export completed successfully! File saved as: {excel_file}")
            
        importer.info("\nInventory import completed successfully!")
        
    except KeyboardInterrupt:
        sys.stderr.write("\n\nOperation cancelled by user.\n")
        sys.exit(1)
    except Exception as e:
        sys.stderr.write(f"\nAn unexpected error occurred: {str(e)}\n")
        sys.exit(1)

if __name__ == "__main__":
    main()
